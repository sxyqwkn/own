<template>
  <div>
    <div class="canvas-container">
      <canvas ref="canvas" :width="maxWidth" :height="maxHeight"></canvas>
    </div>
    <input type="range" min="0" :max="maxScroll" v-model="scrollPosition" class="range"/>
    <input type="number" v-model="speed" placeholder="スビート" style="width: 40px;"/>
    <button @click="moveLeft">戻し</button>
    <button @click="stopMoving">停止</button>
    <button @click="moveRight">送り</button> |
    <button @click="copyToClipboard">コピー</button> |
    <input type="date" :min="minDate" :max="maxDate" v-model="selectedDate"/>
    <button @click="goByDate">Go</button>
    
  </div>
</template>
<script>
import { fabric } from 'fabric';
import * as d3 from 'd3';

export default {
  data() {
    return {

      /** 
       * オプション
      */
      // canvasのサイズ
      maxWidth: 1100,
      maxHeight: 600,

      // ズームのリミット
      maxZoom: 20,
      minZoom: 0.1,

      // 送り機能とかで、予めロードする画像の範囲
      Preload: 100,

      /** 
       * 読み込みデータ
      */
      // チャート
      chert: [],
      chertNum: 0,

      /** 
      * パラメータ
      */
      images: require.context('@/assets/', false, /\.png$/),
      isTimePosMode: false,

      // canvas
      canvas: null,
      overImg: null,
      loadedImg: [],
      timeLine: null,
      timeLineImg: null,
      gridLine: null,

      // 日付選択用
      minDate: "1999-12-31",
      maxDate: "1999-12-31",
      selectedDate: "1999-12-31",

      // スクロール
      scrollPosition: 0,
      maxScroll: 0,

      // 再生
      speed: 1,          
      intervalId: null
    };
  },
  mounted() {

    // 一時データ (要求：インデックスが順番)
    // LEN = 47082
    this.chert.push({ url: 'C0801.png', startDate: new Date(2023,10,30,0,0,0), endDate: new Date(2023,11,1,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0802.png', startDate: new Date(2023,10,1,0,0,0), endDate: new Date(2023,11,3,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0803.png', startDate: new Date(2023,10,3,0,0,0), endDate: new Date(2023,11,5,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0804.png', startDate: new Date(2023,10,5,0,0,0), endDate: new Date(2023,11,7,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0805.png', startDate: new Date(2023,10,7,0,0,0), endDate: new Date(2023,11,10,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0801.png', startDate: new Date(2023,10,30,0,0,0), endDate: new Date(2023,11,1,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0802.png', startDate: new Date(2023,10,1,0,0,0), endDate: new Date(2023,11,3,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0803.png', startDate: new Date(2023,10,3,0,0,0), endDate: new Date(2023,11,5,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0804.png', startDate: new Date(2023,10,5,0,0,0), endDate: new Date(2023,11,7,0,0,0), len: 2413, height: 615});
    this.chert.push({ url: 'C0805.png', startDate: new Date(2023,10,7,0,0,0), endDate: new Date(2023,11,10,0,0,0), len: 2413, height: 615});
    

    // 初期化
    this.chertNum = 0;
    this.minDate = this.chert[0].startDate.toLocaleDateString('ja-JP').replaceAll('/','-');
    this.maxDate = this.chert[this.chert.length -1].endDate.toLocaleDateString('ja-JP').replaceAll('/','-');
    this.selectedDate = this.minDate

    // スクロール最大値設定
    this.chert.forEach((item) => {
      item.leftPosition = this.maxScroll
      this.maxScroll += item.len * (this.maxHeight / item.height);
    });
    console.log(this.maxScroll);
    this.maxScroll -= this.maxWidth;

    // 0.05MB
    fabric.minCacheSideLimit = 52429;

    // canvasのロード
    this.canvas = new fabric.Canvas(this.$refs.canvas, {fireRightClick: true});
    this.canvas.wrapperEl.oncontextmenu = () => false;

    // 最初の図とタイムラインのロード
    this.loadImage(this.chertNum).then(() => {
      this.createTimeline();
      this.createGridLines(100,40);
    });

    // プリロード
    for (let i = 0; i < this.chert.length; i++) {
      if (this.chert[i].leftPosition < this.maxWidth + this.Preload) {
        this.loadImage(i);
      }
      else {
        break;
      }
    }

    this.setupEvents();
  },
  methods: {

    /** 
     * 図のロード
    */
    loadImage(chertNum) {

      return new Promise((resolve) => {
        fabric.Image.fromURL(this.images('./' + this.chert[chertNum].url), (img) => {

          // 初期ズーム
          img.scale(this.maxHeight / img.height);

          if(this.overImg) {

            img.set({
              left: this.chert[chertNum].leftPosition + this.overImg.left,
              selectable: false
            });

            let group = new fabric.Group([this.overImg, img]);
            group.selectable = false;

            this.overImg = group
          }
          else {

            img.set({
              left: this.chert[chertNum].leftPosition,
              selectable: false
            });

            img.selectable = false;
            this.overImg = img
          }
          
          this.loadedImg.push({num: chertNum, img: img})
          this.canvas.add(img);

          if(this.timeLineImg) {
            this.timeLineImg.bringToFront();
          }
          if(this.gridLine) {
            this.gridLine.bringToFront();
          }

          resolve();
        });
      });
    },

    /** 
    * タイムライン作成
    */
    createTimeline() {

      // ライン作成
      let scale = d3.scaleTime()
        .domain([this.chert[0].startDate, this.chert[this.chert.length -1].endDate])
        .range([0, this.maxScroll + this.maxWidth]);

      // 尺度作成
      let axis = d3.axisBottom(scale)
        .ticks(d3.timeDay.every(1))
        .tickFormat(d3.timeFormat("%Y-%m-%d"));

      // svg対象を作成
      let svg = d3.create("svg").append('g').call(axis);

      // 尺度文字の位置を調整
      svg.selectAll('.tick text')
        .style('text-anchor', 'start')
        .style('fill', '#000')
        .attr('dx', '0.5em');

      svg.selectAll('.tick text')
        .filter((d, i, nodes) => i === nodes.length - 1)
        .style('text-anchor', 'end')
        .attr('dx', '-0.5em');

      svg.selectAll('.domain, .tick line')
        .style('stroke', '#000');

      // svgオブジェクトを文字列に変更
      let svgString = new XMLSerializer().serializeToString(svg.node());

      // svg文字列とfabric対象に変更
      fabric.loadSVGFromString(svgString, (objects, options) => {
        let group = fabric.util.groupSVGElements(objects, options);

        // fabric対象オプション
        group.set({
          left: 0,
          top: 1,
          hasControls: false,
          lockMovementX: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
          opacity: 0.8
        });

        // canvasに描き
        this.timeLineImg = group;
        this.timeLine = scale;
        this.canvas.add(group);
      });
    },

    /** 
    * グリッド線作成
    */
    createGridLines(gridWidth, gridHeight) {
      let gridLines = [];

      // 線の仕様
      let opt = {
        stroke: '#000',
        strokeWidth: 1,
        selectable: false,
        opacity: 0.5
      };

      // 縦
      for (let i = gridWidth; i <  this.maxScroll + this.maxWidth; i += gridWidth) {
        gridLines.push(new fabric.Line([i, 0, i, this.overImg.height * (this.maxHeight / this.overImg.height)], opt));
      }

      // 横
      for (let i = gridHeight; i < this.overImg.height * (this.maxHeight / this.overImg.height); i += gridHeight) {
        gridLines.push(new fabric.Line([0, i, this.maxScroll + this.maxWidth, i], opt));
      }

      // fabricのオプション
      let gridGroup = new fabric.Group(gridLines, {
        selectable: false,
        evented: false
      });

      // canvasに描き
      this.canvas.add(gridGroup);
      this.gridLine = gridGroup;
    },

    /** 
     * スクロール
    */
    scrollImage() {

      // 前スクロール
      if(this.overImg.left > -this.scrollPosition) {

        for (let i = this.chertNum + 1; i < this.chert.length; i++) {

          if (this.chert[i].leftPosition < parseFloat(this.scrollPosition) + this.maxWidth + this.Preload) {
            if (i == this.chert.length - 1 || this.chert[i + 1].leftPosition > parseFloat(this.scrollPosition)) {

              this.chertNum = i
              if (!this.loadedImg.some(item => item.num == i)) {
                this.loadImage(i);
              }
              if (!this.loadedImg.some(item => item.num == i - 1)) {
                this.loadImage(i - 1);
              }
            }
          }
        }
      }

      // 後ろスクロール
      else {
        for (let i = this.chertNum - 1; i >= 0; i--) {

          if (this.chert[i].leftPosition < parseFloat(this.scrollPosition) + this.maxWidth + this.Preload) {
            if (i == this.chert.length - 1 || this.chert[i + 1].leftPosition > parseFloat(this.scrollPosition)) {

              this.chertNum = i
              if (!this.loadedImg.some(item => item.num == i)) {
                this.loadImage(i);
              }
              if (i != 0 && !this.loadedImg.some(item => item.num == i - 1)) {
                this.loadImage(i - 1);
              }
            }
          }
        }
      }

      this.overImg.left = -this.scrollPosition;
      this.timeLineImg.left = -this.scrollPosition;
      this.gridLine.left = -this.scrollPosition;
      this.canvas.renderAll();
    },

    /** 
     * 送り
    */
    moveRight() {
      this.stopMoving();
      this.intervalId = setInterval(() => {
        if (this.scrollPosition < this.maxScroll) {

          // 文字列を小数に変更して計算
          this.scrollPosition = parseFloat(this.scrollPosition) + this.speed;
          this.scrollImage();

        } else {
          this.stopMoving();
        }
      }, 100);
    },
    
    /** 
     * 戻し
    */
    moveLeft() {
      this.stopMoving(); 
      this.intervalId = setInterval(() => {
        if (this.scrollPosition > 0) {

          this.scrollPosition =  this.scrollPosition - this.speed;
          this.scrollImage();

        } else {
          this.stopMoving();
        }
      }, 100);
    },

    /** 
     * 停止
    */
    stopMoving() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    },

    /** 
     * 時間指定
    */
    goByDate() {

      if(this.selectedDate) {

        let parts = this.selectedDate.split('-');
        let year = parseInt(parts[0], 10);
        let month = parseInt(parts[1], 10) - 1;
        let day = parseInt(parts[2], 10);

        if(this.timeLine(new Date(year,month,day,0,0,0)) <= this.maxScroll) {
          this.scrollPosition = this.timeLine(new Date(year,month,day,0,0,0));
          this.scrollImage();
        }
        else {
          this.scrollPosition = this.maxScroll;
          this.scrollImage();
        }
      }
    },

    /** 
     * クリップボードコピー
    */
    async copyToClipboard() {

      // URLに転換
      const dataUrl = this.canvas.toDataURL();

      try {

        // URLをBlobに転換
        const blob = await (await fetch(dataUrl)).blob();

        // クリップボードにロード
        const item = new ClipboardItem({ 'image/png': blob });
        await navigator.clipboard.write([item]);

        alert('クリップボードにコビーしました');
      } catch (error) {

        // エラー
        alert('エラー');
        console.log(error);
      }
    },

    /** 
     * レスナー
    */
    setupEvents() {

      // mouse:wheel マウスホイール
      this.canvas.on('mouse:wheel', (opt) => {

          // パラメータ取得
          let delta = opt.e.deltaY;
          let zoom = this.canvas.getZoom();

          // 倍率計算
          zoom *= 0.999 ** delta;
          if (zoom > this.maxZoom) {
            zoom = this.maxZoom;
          }
          if (zoom < this.minZoom) {
            zoom = this.minZoom;
          }

          // マウス中心でズーム
          this.canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);

          // デフォルトイベントとバブリング禁止
          opt.e.preventDefault();
          opt.e.stopPropagation();
      });
    },

  },

  watch: {
    scrollPosition() {
      this.scrollImage();
    }
  }
}
</script>

<style scoped>

.canvas-container {
  display: flex;
  justify-content: center;
  margin-bottom: 20px;
}

/* 
.grid {
  border: 1px solid #ccc;
  background-size: 50px 50px;
  background-image:
    linear-gradient(to right, gray 1px, transparent 1px),
    linear-gradient(to bottom, gray 1px, transparent 1px);
}
*/

.range {
  width: 40%;
}

</style>
