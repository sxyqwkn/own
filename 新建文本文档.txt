<template>
  <div>
    <div class="canvas-container">
      <canvas ref="canvas" :width="maxWidth" :height="maxHeight" class="grid"></canvas>
    </div>
    <input type="range" min="0" :max="maxScroll" v-model="scrollPosition" @input="scrollImage" class="range"/>
    <input type="number" v-model="speed" placeholder="スビート" style="width: 40px;"/>
    <button @click="moveLeft">戻し</button>
    <button @click="stopMoving">停止</button>
    <button @click="moveRight">送り</button>
    <button @click="copyToClipboard">コピー</button>
    
  </div>
</template>
<script>
import { fabric } from 'fabric';
import * as d3 from 'd3';

export default {
  data() {
    return {

      /** 
       * オプション
      */
      // canvasのサイズ
      maxWidth: 1100,
      maxHeight: 600,

      /** 
       * 読み込みデータ
      */
      // チャート
      chertUrl: [],
      chertImg: [],
      chertContext: null,
      chertNum: 0,

      // 日付
      startDate: null,
      endDate: null,

      /** 
      * パラメータ
      */
      images: require.context('@/assets/', false, /\.png$/),

      // canvas
      canvas: null,
      img: null,
      timeLine: null,
      gridLine: null,

      // 今の日付
      nowDate: null,

      // スクロール
      scrollPosition: 0,
      maxScroll: 0,

      // 再生
      speed: 1,          
      intervalId: null
    };
  },
  mounted() {

    // 一時データ
    this.chertUrl.push('C0801.png');
    this.chertUrl.push('C0802.png');
    this.chertUrl.push('C0803.png');
    this.chertUrl.push('C0804.png');
    this.chertUrl.push('C0805.png');

    this.startDate = new Date(2023,10,30,0,0,0);
    this.endDate = new Date(2023,11,11,0,0,0);

    // 初期化
    this.nowDate = this.startDate;
    this.chertNum = 0;

    // canvasのロード
    this.canvas = new fabric.Canvas(this.$refs.canvas, {fireRightClick: true});
    this.canvas.wrapperEl.oncontextmenu = () => false;

    // 図とタイムラインのロード
    this.loadImage(this.chertNum).then(() => {
      this.createTimeline();
      this.createGridLines(100,40);
    });

  },
  methods: {

    /** 
     * 図のロード
    */
    loadImage(chertNum) {

      return new Promise((resolve) => {
        fabric.Image.fromURL(this.images('./' + this.chertUrl[chertNum]), (img) => {
          // 初期ズーム
          let scale = this.maxHeight / img.height;
          img.scale(scale);

          // セレクト不可
          img.selectable = false;
          
          // スクロール最大値設定
          this.maxScroll = img.width * scale - this.canvas.width;

          this.img = img;
          this.canvas.add(img);
          img.sendToBack();

          resolve();
        });
      });
    },

    /** 
    * タイムライン作成
    */
    createTimeline() {

      // ライン作成
      let scale = d3.scaleTime()
        .domain([this.startDate, this.endDate])
        .range([0, this.img.width - 60]);

      // 尺度作成
      let axis = d3.axisBottom(scale)
        .ticks(d3.timeDay.every(1))
        .tickFormat(d3.timeFormat("%Y-%m-%d"));

      // svg対象を作成
      let svg = d3.create("svg").append('g').call(axis);

      // 尺度文字の位置を調整
      svg.selectAll('.tick text')
        .style('text-anchor', 'start')

      svg.selectAll('.tick text')
        .filter((d, i, nodes) => i === nodes.length - 1)
        .style('text-anchor', 'end')

      // svgオブジェクトを文字列に変更
      let svgString = new XMLSerializer().serializeToString(svg.node());

      // svg文字列とfabric対象に変更
      fabric.loadSVGFromString(svgString, (objects, options) => {
        let group = fabric.util.groupSVGElements(objects, options);

        // fabric対象オプション
        group.set({
          left: 0,
          top: 1,
          hasControls: false,
          lockMovementX: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
          opacity: 0.8
        });

        // canvasに描き
        this.timeLine = group;
        this.canvas.add(group);
      });
    },

    /** 
    * グリッド線作成
    */
    createGridLines(gridWidth, gridHeight) {
      let gridLines = [];

      // 線の仕様
      let opt = {
        stroke: '#000',
        strokeWidth: 1,
        selectable: false,
        opacity: 0.5
      };

      // 縦
      for (let i = gridWidth; i < this.img.width; i += gridWidth) {
        gridLines.push(new fabric.Line([i, 0, i, this.img.height], opt));
      }

      // 横
      for (let i = gridHeight; i < this.img.height; i += gridHeight) {
        gridLines.push(new fabric.Line([0, i, this.img.width, i], opt));
      }

      // fabricのオプション
      let gridGroup = new fabric.Group(gridLines, {
        selectable: false,
        evented: false
      });

      // canvasに描き
      this.canvas.add(gridGroup);
      this.gridLine = gridGroup;
    },

    /** 
     * スクロール
    */
    scrollImage() {

        this.img.left = -this.scrollPosition;
        this.timeLine.left = -this.scrollPosition;
        this.gridLine.left = -this.scrollPosition;
        this.canvas.renderAll();
    },

    /** 
     * 送り
    */
    moveRight() {
      this.stopMoving();
      this.intervalId = setInterval(() => {
        if (this.scrollPosition < this.maxScroll) {

          // 文字列を小数に変更して計算
          this.scrollPosition = parseFloat(this.scrollPosition) + this.speed;

          this.img.left = -this.scrollPosition;
          this.timeLine.left = -this.scrollPosition;
          this.gridLine.left = -this.scrollPosition;
          this.canvas.renderAll();
        } else {
          this.stopMoving();
        }
      }, 100);
    },
    
    /** 
     * 戻し
    */
    moveLeft() {
      this.stopMoving(); 
      this.intervalId = setInterval(() => {
        if (this.scrollPosition > 0) {

          this.scrollPosition =  this.scrollPosition - this.speed;

          this.img.left = -this.scrollPosition;
          this.timeLine.left = -this.scrollPosition;
          this.gridLine.left = -this.scrollPosition;
          this.canvas.renderAll();
        } else {
          this.stopMoving();
        }
      }, 100);
    },

    /** 
     * 停止
    */
    stopMoving() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    },

    /** 
     * クリップボードコピー
    */
    async copyToClipboard() {

      // URLに転換
      const dataUrl = this.canvas.toDataURL();

      try {

        // URLをBlobに転換
        const blob = await (await fetch(dataUrl)).blob();

        // クリップボードにロード
        const item = new ClipboardItem({ "image/png": blob });
        await navigator.clipboard.write([item]);

        alert('クリップボードにコビーしました');
      } catch (error) {

        // エラー
        alert('エラー');
        console.log(error);
      }
    },

  }
}
</script>

<style scoped>

.canvas-container {
  display: flex;
  justify-content: center;
  margin-bottom: 20px;
}

.grid {
  border: 1px solid #ccc;
  background-size: 50px 50px;
  background-image:
    linear-gradient(to right, gray 1px, transparent 1px),
    linear-gradient(to bottom, gray 1px, transparent 1px);
}

.range {
  width: 40%;
}

</style>
