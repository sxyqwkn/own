<template>
  <div>
    <div class="canvas-container">
      <canvas ref="canvas" :width="maxWidth" :height="maxHeight"></canvas>
    </div>
    <input type="range" min="0" :max="maxScroll" v-model="scrollPosition" class="range"/>
    <input type="number" v-model="speed" placeholder="スビート" style="width: 40px;"/>
    <button @click="moveLeft">戻し</button>
    <button @click="stopMoving">停止</button>
    <button @click="moveRight">送り</button> |
    <button @click="copyToClipboard">コピー</button> |
    <input type="date" :min="minDate" :max="maxDate" v-model="selectedDate"/>
    <button @click="goByDate">Go</button>
    
  </div>
</template>
<script>
import { fabric } from 'fabric';
import * as d3 from 'd3';

export default {
  data() {
    return {

      /** 
       * オプション
      */
      // canvasのサイズ
      maxWidth: 1100,
      maxHeight: 600,

      // ズームのリミット
      maxZoom: 20,
      minZoom: 0.1,

      // 時間軸で一日の幅
      dayWidth: 1200,

      // 送り機能とかで、予めロードする画像の範囲
      Preload: 100,

      /** 
       * 読み込みデータ
      */
      // チャート
      chert: [],
      chertNum: 0,
      // 時刻基点情報
      timeBase: [],

      /** 
      * パラメータ
      */
      images: require.context('@/assets/', false, /\.png$/),
      isTimeBaseMode: true,
      cutParts: [],

      // canvas
      canvas: null,
      overImg: null,
      loadedImg: [],
      timeLine: null,
      timeLineImg: null,
      gridLine: null,

      // 日付選択用
      minDate: "1999-12-31",
      maxDate: "1999-12-31",
      selectedDate: "1999-12-31",

      // スクロール
      scrollPosition: 0,
      maxScroll: 0,

      // 再生
      speed: 1,          
      intervalId: null
    };
  },
  mounted() {

    // 画像情報
    this.chert.push({id: 'C0801', url: 'C0801.png', startDate: new Date(2023,10,29,0,0,0), endDate: new Date(2023,11,1,0,0,0), len: 2413, height: 615});
    this.chert.push({id: 'C0802', url: 'C0802.png', startDate: new Date(2023,11,1,0,0,0), endDate: new Date(2023,11,3,0,0,0), len: 2413, height: 615});
    this.chert.push({id: 'C0803', url: 'C0803.png', startDate: new Date(2023,11,3,0,0,0), endDate: new Date(2023,11,5,0,0,0), len: 2413, height: 615});
    this.chert.push({id: 'C0804', url: 'C0804.png', startDate: new Date(2023,11,5,0,0,0), endDate: new Date(2023,11,7,0,0,0), len: 2413, height: 615});
    this.chert.push({id: 'C0805', url: 'C0805.png', startDate: new Date(2023,11,7,0,0,0), endDate: new Date(2023,11,9,0,0,0), len: 2413, height: 615});

    // 時刻基点情報
    this.timeBase.push({ form: 'C0803', Date: new Date(2023,11,3,9,0,0), type: 0});
    this.timeBase.push({ form: 'C0804', Date: new Date(2023,11,6,18,0,0), type: 1});
    this.timeBase.push({ form: 'C0805', Date: new Date(2023,11,7,9,0,0), type: 0});
    this.timeBase.push({ form: 'C0805', Date: new Date(2023,11,8,18,0,0), type: 1});
    
    // 画面初期化
    this.minDate = this.formatDate(this.chert[0].startDate);
    this.maxDate = this.formatDate(this.chert[this.chert.length -1].endDate);
    this.selectedDate = this.minDate;
    this.chertNum = 0;

    // canvasのロード
    this.canvas = new fabric.Canvas(this.$refs.canvas, {fireRightClick: true});
    this.canvas.wrapperEl.oncontextmenu = () => false;

    // スクロール最大値設定
    let day = ((this.chert[this.chert.length -1].endDate - this.chert[0].startDate) / 86400000);
    this.maxScroll = this.dayWidth * day - this.maxWidth;

    // タイムラインとグリッド線
    this.createTimeline(this.chert[0].startDate, this.chert[this.chert.length -1].endDate, this.dayWidth * day);
    this.createGridLines(this.dayWidth / 24, 25, this.dayWidth * day);

    // 時間基点ベースの場合 各画像の画像開始位置を算出 スクロール最大値再計算 時間軸のカット
    if(this.isTimeBaseMode) {

      let cutTal = 0;
      for (let i = 0; i < this.chert.length; i++) {

        // 画像開始位置設定
        this.chert[i].leftPosition = this.timeLine(this.chert[i].startDate) - cutTal;

        // 時間基点情報検索
        let timeBaseInfo = this.timeBase.filter(item =>  item.form == this.chert[i].id);

        timeBaseInfo.forEach((item) => {
          // 開始位置の場合
          if (!item.type) {
            cutTal += this.timeLine(item.Date) - this.timeLine(this.chert[i].startDate);
            this.cutParts.push({ start: this.timeLine(this.chert[i].startDate), size: this.timeLine(item.Date) - this.timeLine(this.chert[i].startDate)});
          }
          // 終了位置の場合
          else {
            cutTal += this.timeLine(this.chert[i].endDate) - this.timeLine(item.Date);
            this.cutParts.push({ start: this.timeLine(item.Date), size: this.timeLine(this.chert[i].endDate) - this.timeLine(item.Date)});
          }
        });
      }

      // スクロール最大値再計算
      this.maxScroll -= cutTal;
    }
    // 時間基点ベースではない場合 各画像の画像開始位置を算出
    else {
      this.chert.forEach((item) => {
        item.leftPosition = this.timeLine(item.startDate);
      });
    }

    // 時間軸の画像を作成
    this.createTimelineImg(this.timeLine)

    // 0.05MB
    // fabric.minCacheSideLimit = 52429;

    // 最初の図とタイムラインのロード
    this.loadImage(this.chertNum);

    this.setupEvents();
  },
  methods: {

    /** 
     * 図のロード
    */
    loadImage(chertNum) {
      return new Promise((resolve) => {
        fabric.Image.fromURL(this.images('./' + this.chert[chertNum].url), (img) => {

          // 初期ズームデータ
          let scaleY = this.maxHeight / img.height;
          let scaleX = this.dayWidth * (this.chert[chertNum].endDate - this.chert[chertNum].startDate) / 86400000 / img.width;

          if(this.isTimeBaseMode) {
            // クリッピングパラメータ
            let imgElement = img.getElement();

            let clipLeft = 0;
            let leftCutPart = this.timeBase.find(item => item.form == this.chert[chertNum].id && item.type == 0);
            if (leftCutPart) {
              clipLeft = this.timeLine(leftCutPart.Date) - this.timeLine(this.chert[chertNum].startDate);
            }
            
            let clipWidth = img.width - clipLeft;
            let rightCutPart = this.timeBase.find(item => item.form == this.chert[chertNum].id && item.type == 1);
            if (rightCutPart) {
              clipWidth -= this.timeLine(this.chert[chertNum].endDate) - this.timeLine(rightCutPart.Date);
            }

            // 一時的Canvasを作成
            let tempCanvas = document.createElement('canvas');
            let ctx = tempCanvas.getContext('2d');
            tempCanvas.width = clipWidth;
            tempCanvas.height = img.height;

            // 画像を描き
            ctx.drawImage(imgElement, clipLeft, 0, clipWidth, img.height, 0, 0, clipWidth, img.height);

            // DataURLに変換
            let dataURL = tempCanvas.toDataURL();

            // クリッピング後の画像でfabric.Imageを作成する
            fabric.Image.fromURL(dataURL, (imgTimeBase) => {
              img = imgTimeBase;
            })
          }
          
          if(this.overImg) {

            img.set({
              scaleX: scaleX,
              scaleY: scaleY,
              left: this.chert[chertNum].leftPosition + this.overImg.left,
              selectable: false
            });

            let group = new fabric.Group([this.overImg, img]);
            group.selectable = false;

            this.overImg = group
          }
          else {

            img.set({
              scaleX: scaleX,
              scaleY: scaleY,
              left: this.chert[chertNum].leftPosition,
              selectable: false
            });

            this.overImg = img
          }
          
          this.loadedImg.push({num: chertNum, img: img})
          this.canvas.add(img);

          if(this.timeLineImg) {
            this.timeLineImg.bringToFront();
          }
          if(this.gridLine) {
            this.gridLine.bringToFront();
          }
          

          resolve();
        });
      });
    },

    /** 
    * タイムライン作成
    * 
    */
    createTimeline(startDate, endDate, length) {

      // ライン作成
      let scale = d3.scaleTime()
        .domain([startDate, endDate])
        .range([0, length]);

      this.timeLine = scale;
    },

    /** 
    * タイムライン画像作成
    */
    createTimelineImg(scale) {

      // 尺度作成
      let axis = d3.axisBottom(scale)
        .ticks(d3.timeDay.every(1))
        .tickFormat(d3.timeFormat("%Y-%m-%d"));

      // svg対象を作成
      let svg = d3.create("svg").append('g').call(axis);

      // 尺度文字の位置を調整
      svg.selectAll('.tick text')
        .style('text-anchor', 'start')
        .style('fill', '#000')
        .attr('dx', '0.5em');

      svg.selectAll('.tick text')
        .filter((d, i, nodes) => i === nodes.length - 1)
        .style('text-anchor', 'end')
        .attr('dx', '-0.5em');

      svg.selectAll('.domain, .tick line')
        .style('stroke', '#000');

      // svgオブジェクトを文字列に変更
      let svgString = new XMLSerializer().serializeToString(svg.node());

      // 時刻基点モードで時間軸をカットする
      if (this.isTimeBaseMode) {

        svgString = svgString.replace(/translate\((\d+),(\d+)\)/g, (match, p1, p2) => {

          let totalCutSize = this.cutParts
            .filter(part => parseInt(p1) > part.start)
            .reduce((sum, current) => sum + current.size, 0);

          let newp1 = parseInt(p1) - totalCutSize;
          return `translate(${newp1},${p2})`;
        });

        svgString = svgString.replace(/H(\d+)/g, (match, p1) => {

          let totalCutSize = this.cutParts
            .filter(part => parseInt(p1) > part.start)
            .reduce((sum, current) => sum + current.size, 0);

          let newp1 = parseInt(p1) - totalCutSize;
          return `H${newp1}`;
        });
      }

      // svg文字列とfabric対象に変更
      fabric.loadSVGFromString(svgString, (objects, options) => {
        let group = fabric.util.groupSVGElements(objects, options);

        // fabric対象オプション
        group.set({
          left: 0,
          top: 1,
          hasControls: false,
          lockMovementX: true,
          lockRotation: true,
          lockScalingX: true,
          lockScalingY: true,
          opacity: 0.8,

          // Cache禁止
          objectCaching: false,
        });

        // canvasに描き
        this.timeLineImg = group;
        this.canvas.add(group);
      });
    },

    /** 
    * グリッド線作成
    */
    createGridLines(gridWidth, gridHeight, length) {
      let gridLines = [];

      // 線の仕様
      let opt = {
        stroke: '#000',
        strokeWidth: 1,
        selectable: false,
        opacity: 0.5
      };

      // 縦
      for (let i = gridWidth; i <  length; i += gridWidth) {
        gridLines.push(new fabric.Line([i, 0, i, this.maxHeight], opt));
      }

      // 横
      for (let i = gridHeight; i < this.maxHeight; i += gridHeight) {
        gridLines.push(new fabric.Line([0, i, length, i], opt));
      }

      // fabricのオプション
      let gridGroup = new fabric.Group(gridLines, {
        selectable: false,
        evented: false,

        // Cache禁止
        objectCaching: false,
      });

      // canvasに描き
      this.canvas.add(gridGroup);
      this.gridLine = gridGroup;
    },

    /** 
     * スクロール
    */
    scrollImage() {

      // 前スクロール
      if(this.overImg.left > -this.scrollPosition) {

        for (let i = this.chertNum + 1; i < this.chert.length; i++) {

          if (this.chert[i].leftPosition < parseFloat(this.scrollPosition) + this.maxWidth + this.Preload) {
            if (i == this.chert.length - 1 || this.chert[i + 1].leftPosition > parseFloat(this.scrollPosition)) {

              this.chertNum = i
              if (!this.loadedImg.some(item => item.num == i)) {
                this.loadImage(i);
              }
              if (!this.loadedImg.some(item => item.num == i - 1)) {
                this.loadImage(i - 1);
              }
            }
          }
        }
      }

      // 後ろスクロール
      else {
        for (let i = this.chertNum - 1; i >= 0; i--) {

          if (this.chert[i].leftPosition < parseFloat(this.scrollPosition) + this.maxWidth + this.Preload) {
            if (i == this.chert.length - 1 || this.chert[i + 1].leftPosition > parseFloat(this.scrollPosition)) {

              this.chertNum = i
              if (!this.loadedImg.some(item => item.num == i)) {
                this.loadImage(i);
              }
              if (i != 0 && !this.loadedImg.some(item => item.num == i - 1)) {
                this.loadImage(i - 1);
              }
            }
          }
        }
      }

      this.overImg.left = -this.scrollPosition;
      this.timeLineImg.left = -this.scrollPosition;
      this.gridLine.left = -this.scrollPosition;
      this.canvas.renderAll();
    },

    /** 
     * 送り
    */
    moveRight() {
      this.stopMoving();
      this.intervalId = setInterval(() => {
        if (this.scrollPosition < this.maxScroll) {

          // 文字列を小数に変更して計算
          this.scrollPosition = parseFloat(this.scrollPosition) + this.speed;
          this.scrollImage();

        } else {
          this.stopMoving();
        }
      }, 100);
    },
    
    /** 
     * 戻し
    */
    moveLeft() {
      this.stopMoving(); 
      this.intervalId = setInterval(() => {
        if (this.scrollPosition > 0) {

          this.scrollPosition =  this.scrollPosition - this.speed;
          this.scrollImage();

        } else {
          this.stopMoving();
        }
      }, 100);
    },

    /** 
     * 停止
    */
    stopMoving() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    },

    /** 
     * 時間指定
    */
    goByDate() {

      if(this.selectedDate) {

        let parts = this.selectedDate.split('-');
        let year = parseInt(parts[0], 10);
        let month = parseInt(parts[1], 10) - 1;
        let day = parseInt(parts[2], 10);

        if(this.timeLine(new Date(year,month,day,0,0,0)) <= this.maxScroll) {

          this.scrollPosition = this.timeLine(new Date(year,month,day,0,0,0));

          for (let i = this.cutParts.length - 1; i >= 0; i--) {
            if (this.cutParts[i].start < this.scrollPosition) {
              this.scrollPosition -= this.cutParts[i].size
            }
          }
          this.scrollImage();
        }
        else {
          this.scrollPosition = this.maxScroll;
          this.scrollImage();
        }
      }
    },

    /** 
     * クリップボードコピー
    */
    async copyToClipboard() {

      // URLに転換
      const dataUrl = this.canvas.toDataURL();

      try {

        // URLをBlobに転換
        const blob = await (await fetch(dataUrl)).blob();

        // クリップボードにロード
        const item = new ClipboardItem({ 'image/png': blob });
        await navigator.clipboard.write([item]);

        alert('クリップボードにコビーしました');
      } catch (error) {

        // エラー
        alert('エラー');
        console.log(error);
      }
    },

    /** 
     * レスナー(拡大機能)
    */
    setupEvents() {

      // mouse:wheel マウスホイール
      this.canvas.on('mouse:wheel', (opt) => {

          // パラメータ取得
          let delta = opt.e.deltaY;
          let zoom = this.canvas.getZoom();

          // 倍率計算
          zoom *= 0.999 ** delta;
          if (zoom > this.maxZoom) {
            zoom = this.maxZoom;
          }
          if (zoom < this.minZoom) {
            zoom = this.minZoom;
          }

          // マウス中心でズーム
          this.canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);

          // デフォルトイベントとバブリング禁止
          opt.e.preventDefault();
          opt.e.stopPropagation();
      });
    },

    formatDate(date) {
      var year = date.getFullYear();
      var month = date.getMonth() + 1;
      var day = date.getDate();

      month = month < 10 ? '0' + month : month;
      day = day < 10 ? '0' + day : day;
      return year + '-' + month + '-' + day;
    }

  },

  watch: {
    scrollPosition() {
      this.scrollImage();
    }
  }
}
</script>

<style scoped>

.canvas-container {
  display: flex;
  justify-content: center;
  margin-bottom: 20px;
}

/* 
.grid {
  border: 1px solid #ccc;
  background-size: 50px 50px;
  background-image:
    linear-gradient(to right, gray 1px, transparent 1px),
    linear-gradient(to bottom, gray 1px, transparent 1px);
}
*/

.range {
  width: 40%;
}

</style>
